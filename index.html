<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8">
<title>Mapa 3D z koordynatami NMS</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
  #renderCanvas { width:100vw; height:100vh; touch-action:none; display:block; }
  #hud {
    position: absolute; top: 10px; left: 10px; padding:10px;
    background: rgba(0,0,0,0.6); color:white; border-radius:5px;
    font-size:14px;
  }
  #hud input { width:120px; margin:2px; }
  #hud button { margin:3px; }
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div id="hud">
  <div>
    X: <input type="number" id="xInput" value="0">
    Y: <input type="number" id="yInput" value="0">
    Z: <input type="number" id="zInput" value="0">
  </div>

  <div>
    Galactic: <input type="text" id="coordInput" placeholder="AAAA:BBBB:CCCC:DDDD">
  </div>

  <div>
    Portal: <input type="text" id="portalInput" placeholder="003DFD6ACF8C">
  </div>

  <div>
    <button id="addPoint">Dodaj</button>
    <button id="zoomToPoint">Zoom</button>
    <button id="editPoint">Edytuj</button>
    <button id="deletePoint">Usuń</button>
  </div>
</div>
  
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// === Kamera i światło ===
const camera = new BABYLON.ArcRotateCamera("camera", Math.PI/4, Math.PI/4, 100, new BABYLON.Vector3(0,0,0), scene);
camera.attachControl(canvas, true);
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

// === Skybox ===
const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:10000}, scene);
const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);
skyboxMaterial.backFaceCulling = false;
skyboxMaterial.disableLighting = true;
skyboxMaterial.diffuseColor = new BABYLON.Color3(0,0,0);
skyboxMaterial.specularColor = new BABYLON.Color3(0,0,0);
skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
  "https://raw.githubusercontent.com/eLeRCreative84/NMS-Planet-Atlasv2/main/textures/skybox/sky1",
  scene
);
skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
skybox.material = skyboxMaterial;

// === Punkty i połączenia ===
let points = [];
let lines = [];
let selectedPoint = null;

const pointMaterial = new BABYLON.StandardMaterial("pointMat", scene);
pointMaterial.emissiveColor = new BABYLON.Color3(0,1,0);
const selectedMaterial = new BABYLON.StandardMaterial("selectedMat", scene);
selectedMaterial.emissiveColor = new BABYLON.Color3(1,0,0);

// === Funkcje pomocnicze ===
function focusCameraOn(point, distance = 30) {
  const target = point.position.clone();
  const direction = camera.position.subtract(camera.target).normalize().scale(distance);
  const newPosition = target.add(direction);
  BABYLON.Animation.CreateAndStartAnimation("camMove", camera, "position", 60, 60,
    camera.position.clone(), newPosition, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
  BABYLON.Animation.CreateAndStartAnimation("camTarget", camera, "target", 60, 60,
    camera.target.clone(), target, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
}

function addPoint(x, y, z, meta = {}) {
  // zachowaj prevSelected lokalnie (stan przed dodaniem)
  const prevSelected = selectedPoint;

  // Tworzymy nowy punkt
  const sphere = BABYLON.MeshBuilder.CreateSphere(`p${points.length}`, { diameter: 2 }, scene);
  sphere.position.set(x, y, z);
  sphere.material = pointMaterial.clone();
  sphere.metadata = meta;

  // Jeśli istniał wcześniej zaznaczony punkt, utwórz linię z prevSelected -> new sphere
  if (prevSelected && prevSelected !== sphere) {
    const path = [prevSelected.position, sphere.position];
    const line = BABYLON.MeshBuilder.CreateLines("line", { points: path }, scene);
    line.color = new BABYLON.Color3(1, 1, 0);
    line.metadata = { a: prevSelected, b: sphere };
    lines.push(line);
  }

  points.push(sphere);

  // Kliknięcie w punkt (ustawienie zaznaczenia)
  sphere.actionManager = new BABYLON.ActionManager(scene);
  sphere.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
    BABYLON.ActionManager.OnPickTrigger,
    function() {
      if (selectedPoint) selectedPoint.material = pointMaterial.clone();
      selectedPoint = sphere;
      selectedPoint.material = selectedMaterial;

      const meta = selectedPoint.metadata || {};
      document.getElementById("xInput").value = selectedPoint.position.x.toFixed(2);
      document.getElementById("yInput").value = selectedPoint.position.y.toFixed(2);
      document.getElementById("zInput").value = selectedPoint.position.z.toFixed(2);
      document.getElementById("coordInput").value = meta.galactic || "";
      document.getElementById("portalInput").value = meta.portal || "";
    }
  ));

  // TERAZ ustawiamy zaznaczenie na nowy punkt (jedyny punkt, który zmienia globalny stan)
  if (selectedPoint) selectedPoint.material = pointMaterial.clone();
  selectedPoint = sphere;
  selectedPoint.material = selectedMaterial;

  // Aktualizujemy HUD dopiero po ustawieniu selectedPoint
  document.getElementById("xInput").value = x.toFixed(2);
  document.getElementById("yInput").value = y.toFixed(2);
  document.getElementById("zInput").value = z.toFixed(2);
  document.getElementById("coordInput").value = meta.galactic || "";
  document.getElementById("portalInput").value = meta.portal || "";

  // opcjonalnie wyczyść pola wejściowe NMS, jeśli chcesz
  // document.getElementById("coordInput").value = "";
  // document.getElementById("portalInput").value = "";

  // i wreszcie zoom
  focusCameraOn(selectedPoint);
}

// Zastępuje Twój event listener dla przycisku 'Dodaj' (usuń duplikujące aktualizacje po addPoint)
document.getElementById('addPoint').addEventListener('click',()=>{
  const coordVal = document.getElementById('coordInput').value.trim();
  const portalVal = document.getElementById('portalInput').value.trim();

  let x, y, z, gal, portal;

  if (coordVal && coordVal.includes(':')) {
    try {
      const res = galacticToXYZ(coordVal);
      x = res.x; y = res.y; z = res.z;
      gal = coordVal;
      portal = xyzToPortal(x,y,z);
    } catch(e){ return alert(e.message); }

  } else if (portalVal && portalVal.length === 12) {
    try {
      const res = portalToXYZ(portalVal);
      x = res.x; y = res.y; z = res.z;
      gal = xyzToGalactic(x,y,z);
      portal = portalVal;
    } catch(e){ return alert(e.message); }

  } else {
    x = parseFloat(document.getElementById('xInput').value);
    y = parseFloat(document.getElementById('yInput').value);
    z = parseFloat(document.getElementById('zInput').value);
    gal = xyzToGalactic(x,y,z);
    portal = xyzToPortal(x,y,z);
  }

  // Nie aktualizujemy pola HUD tutaj — addPoint zrobi to poprawnie.
  addPoint(x,y,z,{galactic:gal,portal});
});

// === Konwersje ===
function galacticToXYZ(g) {
  const parts = g.split(':');
  if (parts.length !== 4) throw new Error("Format AAAA:BBBB:CCCC:DDDD");
  const [sys, bx, by, bz] = parts;
  return { x: parseInt(bx, 16), y: parseInt(by, 16), z: parseInt(bz, 16), system: sys };
}
function xyzToGalactic(x,y,z) {
  return `FFFF:${x.toString(16).padStart(4,'0')}:${y.toString(16).padStart(4,'0')}:${z.toString(16).padStart(4,'0')}`;
}
function xyzToPortal(x,y,z) {
  return (x & 0xFFF).toString(16).padStart(4,'0') +
         (y & 0xFFF).toString(16).padStart(4,'0') +
         (z & 0xFFF).toString(16).padStart(4,'0');
}
function portalToXYZ(p) {
  if (p.length !== 12) throw new Error("Portal ma 12 znaków hex!");
  return {
    x: parseInt(p.slice(0,4),16),
    y: parseInt(p.slice(4,8),16),
    z: parseInt(p.slice(8,12),16)
  };
}

// === HUD ===
document.getElementById('addPoint').addEventListener('click',()=>{
  const coordVal = coordInput.value.trim();
  const portalVal = portalInput.value.trim();

  let x, y, z, gal, portal;

  if (coordVal.includes(':')) {
    const res = galacticToXYZ(coordVal);
    x = res.x; y = res.y; z = res.z;
    gal = coordVal;
    portal = xyzToPortal(x,y,z);
  } else if (portalVal.length === 12) {
    const res = portalToXYZ(portalVal);
    x = res.x; y = res.y; z = res.z;
    gal = xyzToGalactic(x,y,z);
    portal = portalVal;
  } else {
    x = parseFloat(xInput.value);
    y = parseFloat(yInput.value);
    z = parseFloat(zInput.value);
    gal = xyzToGalactic(x,y,z);
    portal = xyzToPortal(x,y,z);
  }

  addPoint(x,y,z,{galactic:gal,portal});
});

document.getElementById('zoomToPoint').addEventListener('click',()=>{
  if (selectedPoint) focusCameraOn(selectedPoint);
});
document.getElementById('editPoint').addEventListener('click',()=>{
  if (!selectedPoint) return alert("Nie zaznaczono punktu!");
  const x=parseFloat(xInput.value), y=parseFloat(yInput.value), z=parseFloat(zInput.value);
  selectedPoint.position.set(x,y,z);
  const gal = xyzToGalactic(x,y,z);
  const portal = xyzToPortal(x,y,z);
  selectedPoint.metadata = {galactic:gal,portal};
  coordInput.value = gal;
  portalInput.value = portal;
  lines.forEach(line=>{
    if(line.metadata.a===selectedPoint||line.metadata.b===selectedPoint)
      BABYLON.MeshBuilder.CreateLines(null,{points:[line.metadata.a.position,line.metadata.b.position],instance:line});
  });
});
document.getElementById('deletePoint').addEventListener('click',()=>{
  if(!selectedPoint) return alert("Nie zaznaczono punktu!");
  lines = lines.filter(line=>{
    if(line.metadata.a===selectedPoint||line.metadata.b===selectedPoint){ line.dispose(); return false;}
    return true;
  });
  points = points.filter(p=>p!==selectedPoint);
  selectedPoint.dispose();
  selectedPoint=null;
});

// === Render ===
engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>

</body>
</html>

