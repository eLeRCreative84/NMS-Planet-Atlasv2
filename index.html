<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8">
<title>Mapa 3D z skyboxem z GitHub</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
  #renderCanvas { width:100vw; height:100vh; touch-action:none; display:block; }
  #hud {
    position: absolute; top: 10px; left: 10px; padding:10px;
    background: rgba(0,0,0,0.6); color:white; border-radius:5px;
  }
  #hud input { width:50px; margin-right:5px; }
  #hud button { margin-left:5px; }
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div id="hud">
  X: <input type="number" id="xInput" value="0">
  Y: <input type="number" id="yInput" value="0">
  Z: <input type="number" id="zInput" value="0">
  <button id="addPoint">Dodaj</button>
  <button id="editPoint">Edytuj</button>
  <button id="deletePoint">Usuń</button>
  <button id="zoomToPoint">Zoom</button>
</div>
  
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// Kamera orbitująca
const camera = new BABYLON.ArcRotateCamera("camera", Math.PI/4, Math.PI/4, 100, new BABYLON.Vector3(0,0,0), scene);
camera.attachControl(canvas, true);

// Światło
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

// Skybox
const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:10000}, scene);
const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);
skyboxMaterial.backFaceCulling = false;
skyboxMaterial.disableLighting = true;
skyboxMaterial.diffuseColor = new BABYLON.Color3(0,0,0);
skyboxMaterial.specularColor = new BABYLON.Color3(0,0,0);
skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
  "https://raw.githubusercontent.com/eLeRCreative84/NMS-Planet-Atlasv2/main/textures/skybox/sky1",
  scene
);
skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
skybox.material = skyboxMaterial;

// === PUNKTY I WĘZŁY ===
let points = [];
let lines = [];
let selectedPoint = null;

const pointMaterial = new BABYLON.StandardMaterial("pointMat", scene);
pointMaterial.emissiveColor = new BABYLON.Color3(0, 1, 0); // zielony

const selectedMaterial = new BABYLON.StandardMaterial("selectedMat", scene);
selectedMaterial.emissiveColor = new BABYLON.Color3(1, 0, 0); // czerwony

function addPoint(x, y, z) {
  const sphere = BABYLON.MeshBuilder.CreateSphere(`p${points.length}`, { diameter: 2 }, scene);
  sphere.position.set(x, y, z);
  sphere.material = pointMaterial.clone();

  // Kliknięcie w punkt
  sphere.actionManager = new BABYLON.ActionManager(scene);
  sphere.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
    BABYLON.ActionManager.OnPickTrigger,
    function () {
      if (selectedPoint) selectedPoint.material = pointMaterial.clone();
      selectedPoint = sphere;
      selectedPoint.material = selectedMaterial;

      // Aktualizuj pola w HUD
      document.getElementById("xInput").value = selectedPoint.position.x.toFixed(2);
      document.getElementById("yInput").value = selectedPoint.position.y.toFixed(2);
      document.getElementById("zInput").value = selectedPoint.position.z.toFixed(2);
    }
  ));

  // Połączenie z poprzednim punktem
  if (selectedPoint && selectedPoint !== sphere) {
    const path = [selectedPoint.position, sphere.position];
    const line = BABYLON.MeshBuilder.CreateLines("line", { points: path }, scene);
    line.color = new BABYLON.Color3(1, 1, 0);
    line.metadata = { a: selectedPoint, b: sphere };
    lines.push(line);
  }

  points.push(sphere);

  // Zaznacz nowy punkt
  if (selectedPoint) selectedPoint.material = pointMaterial.clone();
  selectedPoint = sphere;
  selectedPoint.material = selectedMaterial;

  // Kamera – zoom do nowego punktu
  focusCameraOn(selectedPoint);
}

function focusCameraOn(point) {
  const target = point.position.clone();
  const distance = 10;
  const direction = camera.position.subtract(camera.target).normalize().scale(distance);
  const newPosition = target.add(direction);
  BABYLON.Animation.CreateAndStartAnimation("camMove", camera, "position", 60, 60,
    camera.position.clone(), newPosition, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
  BABYLON.Animation.CreateAndStartAnimation("camTarget", camera, "target", 60, 60,
    camera.target.clone(), target, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
}

// === HUD ===
document.getElementById('addPoint').addEventListener('click', () => {
  const x = parseFloat(document.getElementById('xInput').value);
  const y = parseFloat(document.getElementById('yInput').value);
  const z = parseFloat(document.getElementById('zInput').value);
  addPoint(x, y, z);
});

document.getElementById('zoomToPoint').addEventListener('click', () => {
  if (selectedPoint) focusCameraOn(selectedPoint);
});

// === NOWE: EDYCJA PUNKTU ===
document.getElementById('editPoint').addEventListener('click', () => {
  if (!selectedPoint) return alert("Nie zaznaczono punktu!");
  const x = parseFloat(document.getElementById('xInput').value);
  const y = parseFloat(document.getElementById('yInput').value);
  const z = parseFloat(document.getElementById('zInput').value);
  selectedPoint.position.set(x, y, z);

  // Odśwież linie powiązane
  lines.forEach(line => {
    if (line.metadata.a === selectedPoint || line.metadata.b === selectedPoint) {
      line = BABYLON.MeshBuilder.CreateLines(null, {
        points: [line.metadata.a.position, line.metadata.b.position],
        instance: line
      });
    }
  });
});

// === NOWE: USUWANIE PUNKTU ===
document.getElementById('deletePoint').addEventListener('click', () => {
  if (!selectedPoint) return alert("Nie zaznaczono punktu!");

  // Usuń linie połączone z punktem
  lines = lines.filter(line => {
    if (line.metadata.a === selectedPoint || line.metadata.b === selectedPoint) {
      line.dispose();
      return false;
    }
    return true;
  });

  // Usuń punkt
  points = points.filter(p => p !== selectedPoint);
  selectedPoint.dispose();
  selectedPoint = null;
});

// Render loop
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>



</body>
</html>










