<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8">
<title>Mapa 3D z koordynatami NMS</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
  #renderCanvas { width:100vw; height:100vh; touch-action:none; display:block; }
  #hud {
    position: absolute; top: 10px; left: 10px; padding:10px;
    background: rgba(0,0,0,0.6); color:white; border-radius:5px;
    font-size:14px;
  }
  #hud input { width:120px; margin:2px; }
  #hud button { margin:3px; }
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div id="hud">
  <div>
    X: <input type="number" id="xInput" value="0">
    Y: <input type="number" id="yInput" value="0">
    Z: <input type="number" id="zInput" value="0">
  </div>

  <div>
    Galactic: <input type="text" id="coordInput" placeholder="AAAA:BBBB:CCCC:DDDD">
  </div>

  <div>
    Portal: <input type="text" id="portalInput" placeholder="003DFD6ACF8C">
  </div>

  <div>
    <button id="addPoint">Dodaj</button>
    
    <button id="zoomToPoint">Zoom</button>
    <button id="editPoint">Edytuj</button>
    <button id="deletePoint">Usuń</button>
  </div>
</div>
  
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// === Kamera i światło ===
const camera = new BABYLON.ArcRotateCamera("camera", Math.PI/4, Math.PI/4, 100, new BABYLON.Vector3(0,0,0), scene);
camera.attachControl(canvas, true);
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

// === Skybox ===
const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:10000}, scene);
const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);
skyboxMaterial.backFaceCulling = false;
skyboxMaterial.disableLighting = true;
skyboxMaterial.diffuseColor = new BABYLON.Color3(0,0,0);
skyboxMaterial.specularColor = new BABYLON.Color3(0,0,0);
skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
  "https://raw.githubusercontent.com/eLeRCreative84/NMS-Planet-Atlasv2/main/textures/skybox/sky1",
  scene
);
skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
skybox.material = skyboxMaterial;

// === Punkty i połączenia ===
let points = [];
let lines = [];
let selectedPoint = null;

const pointMaterial = new BABYLON.StandardMaterial("pointMat", scene);
pointMaterial.emissiveColor = new BABYLON.Color3(0,1,0);
const selectedMaterial = new BABYLON.StandardMaterial("selectedMat", scene);
selectedMaterial.emissiveColor = new BABYLON.Color3(1,0,0);

// === Funkcje pomocnicze ===
function focusCameraOn(point) {
  const target = point.position.clone();
  const distance = 20; // było 10 — teraz 2× dalej
  const direction = camera.position.subtract(camera.target).normalize().scale(distance);
  const newPosition = target.add(direction);
  BABYLON.Animation.CreateAndStartAnimation("camMove", camera, "position", 60, 60,
    camera.position.clone(), newPosition, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
  BABYLON.Animation.CreateAndStartAnimation("camTarget", camera, "target", 60, 60,
    camera.target.clone(), target, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
}

function addPoint(x, y, z, meta = {}) {
  const sphere = BABYLON.MeshBuilder.CreateSphere(`p${points.length}`, { diameter: 2 }, scene);
  sphere.position.set(x, y, z);
  sphere.material = pointMaterial.clone();
  sphere.metadata = meta;

  sphere.actionManager = new BABYLON.ActionManager(scene);
  sphere.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
    BABYLON.ActionManager.OnPickTrigger,
    function() {
      if (selectedPoint) selectedPoint.material = pointMaterial.clone();
      selectedPoint = sphere;
      selectedPoint.material = selectedMaterial;
      document.getElementById("xInput").value = sphere.position.x;
      document.getElementById("yInput").value = sphere.position.y;
      document.getElementById("zInput").value = sphere.position.z;
      if (sphere.metadata.galactic) document.getElementById("coordInput").value = sphere.metadata.galactic;
      if (sphere.metadata.portal) document.getElementById("portalInput").value = sphere.metadata.portal;
    }
  ));

  if (selectedPoint && selectedPoint !== sphere) {
    const path = [selectedPoint.position, sphere.position];
    const line = BABYLON.MeshBuilder.CreateLines("line", { points: path }, scene);
    line.color = new BABYLON.Color3(1,1,0);
    line.metadata = { a: selectedPoint, b: sphere };
    lines.push(line);
  }

  points.push(sphere);
  if (selectedPoint) selectedPoint.material = pointMaterial.clone();
  selectedPoint = sphere;
  selectedPoint.material = selectedMaterial;
  focusCameraOn(sphere);
}

// === KONWERSJE ===
function galacticToXYZ(g) {
  const parts = g.split(':');
  if (parts.length !== 4) throw new Error("Format AAAA:BBBB:CCCC:DDDD");
  const [sys, bx, by, bz] = parts;
  return { x: parseInt(bx, 16), y: parseInt(by, 16), z: parseInt(bz, 16), system: sys };
}
function xyzToGalactic(x,y,z) {
  return `FFFF:${x.toString(16).padStart(4,'0')}:${y.toString(16).padStart(4,'0')}:${z.toString(16).padStart(4,'0')}`;
}
function xyzToPortal(x,y,z) {
  // uproszczony mapping (nie 1:1 jak w grze, ale zachowuje unikalność)
  return (x & 0xFFF).toString(16).padStart(4,'0') +
         (y & 0xFFF).toString(16).padStart(4,'0') +
         (z & 0xFFF).toString(16).padStart(4,'0');
}
function portalToXYZ(p) {
  if (p.length !== 12) throw new Error("Portal ma 12 znaków hex!");
  return {
    x: parseInt(p.slice(0,4),16),
    y: parseInt(p.slice(4,8),16),
    z: parseInt(p.slice(8,12),16)
  };
}

// === HUD ===
document.getElementById('addPoint').addEventListener('click',()=>{
  const coordVal = coordInput.value.trim();
  const portalVal = portalInput.value.trim();
  
  let x, y, z, gal, portal;

  if (coordVal.includes(':')) {
    // Wprowadzono galactic coordinates
    try {
      const res = galacticToXYZ(coordVal);
      x = res.x; y = res.y; z = res.z;
      gal = coordVal;
      portal = xyzToPortal(x,y,z);
    } catch(e){ return alert(e.message); }

  } else if (portalVal.length === 12) {
    // Wprowadzono portal address
    try {
      const res = portalToXYZ(portalVal);
      x = res.x; y = res.y; z = res.z;
      gal = xyzToGalactic(x,y,z);
      portal = portalVal;
    } catch(e){ return alert(e.message); }

  } else {
    // Klasyczne XYZ
    x = parseFloat(xInput.value);
    y = parseFloat(yInput.value);
    z = parseFloat(zInput.value);
    gal = xyzToGalactic(x,y,z);
    portal = xyzToPortal(x,y,z);
  }

  addPoint(x,y,z,{galactic:gal,portal});
  xInput.value = x; yInput.value = y; zInput.value = z;
  coordInput.value = gal; portalInput.value = portal;
});

document.getElementById('zoomToPoint').addEventListener('click',()=>{
  if (selectedPoint) focusCameraOn(selectedPoint);
});
document.getElementById('editPoint').addEventListener('click',()=>{
  if (!selectedPoint) return alert("Nie zaznaczono punktu!");
  const x=parseFloat(xInput.value), y=parseFloat(yInput.value), z=parseFloat(zInput.value);
  selectedPoint.position.set(x,y,z);
  const gal = xyzToGalactic(x,y,z);
  const portal = xyzToPortal(x,y,z);
  selectedPoint.metadata = {galactic:gal,portal};
  coordInput.value = gal;
  portalInput.value = portal;
  lines.forEach(line=>{
    if(line.metadata.a===selectedPoint||line.metadata.b===selectedPoint)
      BABYLON.MeshBuilder.CreateLines(null,{points:[line.metadata.a.position,line.metadata.b.position],instance:line});
  });
});
document.getElementById('deletePoint').addEventListener('click',()=>{
  if(!selectedPoint) return alert("Nie zaznaczono punktu!");
  lines = lines.filter(line=>{
    if(line.metadata.a===selectedPoint||line.metadata.b===selectedPoint){ line.dispose(); return false;}
    return true;
  });
  points = points.filter(p=>p!==selectedPoint);
  selectedPoint.dispose();
  selectedPoint=null;
});

// === Render ===
engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>

</body>
</html>

