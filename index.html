<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8">
<title>Mapa 3D NMS – realistyczna konwersja</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
  #renderCanvas { width:100vw; height:100vh; touch-action:none; display:block; }
  #hud {
    position: absolute; top: 10px; left: 10px; padding:10px;
    background: rgba(0,0,0,0.6); color:white; border-radius:5px;
    font-size:14px;
  }
  #hud input { width:120px; margin:2px; }
  #hud button { margin:3px; }
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div id="hud">
  <div>
    X: <input type="number" id="xInput" value="0">
    Y: <input type="number" id="yInput" value="0">
    Z: <input type="number" id="zInput" value="0">
  </div>

  <div>
    Galactic: <input type="text" id="coordInput" placeholder="AAAA:BBBB:CCCC:DDDD">
  </div>

  <div>
    Portal: <input type="text" id="portalInput" placeholder="003DFD6ACF8C">
  </div>

  <div>
    <button id="addPoint">Dodaj</button>
    <button id="zoomToPoint">Zoom</button>
    <button id="editPoint">Edytuj</button>
    <button id="deletePoint">Usuń</button>
  </div>
</div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// === Kamera i światło ===
const camera = new BABYLON.ArcRotateCamera("camera", Math.PI/4, Math.PI/4, 100, new BABYLON.Vector3(0,0,0), scene);
camera.attachControl(canvas, true);
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

// === Skybox ===
const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:10000}, scene);
const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);
skyboxMaterial.backFaceCulling = false;
skyboxMaterial.disableLighting = true;
skyboxMaterial.diffuseColor = new BABYLON.Color3(0,0,0);
skyboxMaterial.specularColor = new BABYLON.Color3(0,0,0);
skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
  "https://raw.githubusercontent.com/eLeRCreative84/NMS-Planet-Atlasv2/main/textures/skybox/sky1",
  scene
);
skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
skybox.material = skyboxMaterial;

// === Punkty i połączenia ===
let points = [];
let lines = [];
let selectedPoint = null;

const pointMaterial = new BABYLON.StandardMaterial("pointMat", scene);
pointMaterial.emissiveColor = new BABYLON.Color3(0,1,0);
const selectedMaterial = new BABYLON.StandardMaterial("selectedMat", scene);
selectedMaterial.emissiveColor = new BABYLON.Color3(1,0,0);

// === Kamera na punkt ===
function focusCameraOn(point, distance = 60) {
  const target = point.position.clone();
  const direction = camera.position.subtract(camera.target).normalize().scale(distance);
  const newPosition = target.add(direction);
  BABYLON.Animation.CreateAndStartAnimation("camMove", camera, "position", 60, 60,
    camera.position.clone(), newPosition, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
  BABYLON.Animation.CreateAndStartAnimation("camTarget", camera, "target", 60, 60,
    camera.target.clone(), target, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
}

// === Dodawanie punktu ===
function addPoint(x, y, z, meta = {}) {
  const sphere = BABYLON.MeshBuilder.CreateSphere(`p${points.length}`, { diameter: 2 }, scene);
  sphere.position.set(x, y, z);
  sphere.material = pointMaterial.clone();
  sphere.metadata = meta;

  // Połączenie z poprzednim punktem
  if (selectedPoint && selectedPoint !== sphere) {
    const path = [selectedPoint.position, sphere.position];
    const line = BABYLON.MeshBuilder.CreateLines("line", { points: path }, scene);
    line.color = new BABYLON.Color3(1, 1, 0);
    line.metadata = { a: selectedPoint, b: sphere };
    lines.push(line);
  }

  points.push(sphere);

  // Obsługa kliknięcia
  sphere.actionManager = new BABYLON.ActionManager(scene);
  sphere.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
    BABYLON.ActionManager.OnPickTrigger,
    function() {
      if (selectedPoint) selectedPoint.material = pointMaterial.clone();
      selectedPoint = sphere;
      selectedPoint.material = selectedMaterial;

      const meta = selectedPoint.metadata || {};
      document.getElementById("xInput").value = selectedPoint.position.x.toFixed(2);
      document.getElementById("yInput").value = selectedPoint.position.y.toFixed(2);
      document.getElementById("zInput").value = selectedPoint.position.z.toFixed(2);
      document.getElementById("coordInput").value = meta.galactic || "";
      document.getElementById("portalInput").value = meta.portal || "";
    }
  ));

  if (selectedPoint) selectedPoint.material = pointMaterial.clone();
  selectedPoint = sphere;
  selectedPoint.material = selectedMaterial;

  // Uaktualnienie HUD
  document.getElementById("xInput").value = x.toFixed(2);
  document.getElementById("yInput").value = y.toFixed(2);
  document.getElementById("zInput").value = z.toFixed(2);
  document.getElementById("coordInput").value = meta.galactic || "";
  document.getElementById("portalInput").value = meta.portal || "";

  focusCameraOn(selectedPoint);
}

// === KONWERSJE ===

// Galaktyczny format -> współrzędne 3D
function galacticToXYZ(g) {
  const parts = g.split(':');
  if (parts.length !== 4) throw new Error("Format musi być AAAA:BBBB:CCCC:DDDD");

  const [region, sx, sy, sz] = parts;
  const x = parseInt(sx, 16);
  const y = parseInt(sy, 16);
  const z = parseInt(sz, 16);

  // Przesuwamy układ, by środek był w (0,0,0)
  const X = x - 2048;
  const Y = y - 128;
  const Z = z - 2048;

  return { x: X, y: Y, z: Z, system: region };
}

// współrzędne -> galaktyczny format (z zachowaniem regionu jako "FFFF")
function xyzToGalactic(x, y, z, system = "FFFF") {
  const sx = (x + 2048).toString(16).padStart(4, '0').toUpperCase();
  const sy = (y + 128).toString(16).padStart(4, '0').toUpperCase();
  const sz = (z + 2048).toString(16).padStart(4, '0').toUpperCase();
  return `${system}:${sx}:${sy}:${sz}`;
}

// === PORTAL KOORDYNATY ===
// uproszczone przybliżenie; portal adresy to inny system 64-bitowy,
// ale zachowamy relację z xyz, by zachować spójność mapy
function xyzToPortal(x, y, z) {
  const px = ((x + 2048) & 0xFFF).toString(16).padStart(3, '0');
  const py = ((y + 128) & 0xFF).toString(16).padStart(2, '0');
  const pz = ((z + 2048) & 0xFFF).toString(16).padStart(3, '0');
  // z prostego powodu łączymy: 003 + X + Y + Z
  return `003${px}${py}${pz}`.toUpperCase();
}

function portalToXYZ(p) {
  if (p.length < 9) throw new Error("Niepoprawny portal address!");
  const x = parseInt(p.slice(3, 6), 16) - 2048;
  const y = parseInt(p.slice(6, 8), 16) - 128;
  const z = parseInt(p.slice(8, 11), 16) - 2048;
  return { x, y, z };
}

// === HUD ===
document.getElementById('addPoint').addEventListener('click',()=>{
  const coordVal = coordInput.value.trim();
  const portalVal = portalInput.value.trim();

  let x, y, z, gal, portal;

  if (coordVal.includes(':')) {
    const res = galacticToXYZ(coordVal);
    x = res.x; y = res.y; z = res.z;
    gal = coordVal;
    portal = xyzToPortal(x,y,z);
  } else if (portalVal.length >= 9) {
    const res = portalToXYZ(portalVal);
    x = res.x; y = res.y; z = res.z;
    gal = xyzToGalactic(x,y,z);
    portal = portalVal;
  } else {
    x = parseFloat(xInput.value);
    y = parseFloat(yInput.value);
    z = parseFloat(zInput.value);
    gal = xyzToGalactic(x,y,z);
    portal = xyzToPortal(x,y,z);
  }

  addPoint(x,y,z,{galactic:gal,portal});
});

document.getElementById('zoomToPoint').addEventListener('click',()=>{
  if (selectedPoint) focusCameraOn(selectedPoint);
});
document.getElementById('editPoint').addEventListener('click',()=>{
  if (!selectedPoint) return alert("Nie zaznaczono punktu!");
  const x=parseFloat(xInput.value), y=parseFloat(yInput.value), z=parseFloat(zInput.value);
  selectedPoint.position.set(x,y,z);
  const gal = xyzToGalactic(x,y,z);
  const portal = xyzToPortal(x,y,z);
  selectedPoint.metadata = {galactic:gal,portal};
  coordInput.value = gal;
  portalInput.value = portal;
  lines.forEach(line=>{
    if(line.metadata.a===selectedPoint||line.metadata.b===selectedPoint)
      BABYLON.MeshBuilder.CreateLines(null,{points:[line.metadata.a.position,line.metadata.b.position],instance:line});
  });
});
document.getElementById('deletePoint').addEventListener('click',()=>{
  if(!selectedPoint) return alert("Nie zaznaczono punktu!");
  lines = lines.filter(line=>{
    if(line.metadata.a===selectedPoint||line.metadata.b===selectedPoint){ line.dispose(); return false;}
    return true;
  });
  points = points.filter(p=>p!==selectedPoint);
  selectedPoint.dispose();
  selectedPoint=null;
});

// === Render ===
engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
