<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8">
<title>Mapa 3D NMS - Regiony</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<style>
body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
#renderCanvas { width:100vw; height:100vh; display:block; touch-action:none; }
#hud {
  position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.6);
  color:white; padding:10px; border-radius:5px; font-size:14px;
}
#hud input { width:100px; margin:2px; }
#hud button { margin:3px; }

/* regionMap: po prawej górze, 4x4 */
#regionMap {
  position:absolute; top:10px; right:10px; width:240px; height:240px;
  background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.08);
  display:grid; grid-template-columns:repeat(4,1fr); grid-template-rows:repeat(4,1fr);
  gap:4px; padding:6px; box-sizing:border-box;
}
.regionTile {
  background:rgba(255,255,255,0.02);
  border:1px solid rgba(255,255,255,0.06);
  cursor:pointer; user-select:none;
}
.regionTile:hover { filter:brightness(1.2); }
.regionTile.selected { outline:2px solid rgba(0,200,0,0.9); }
#regionControls { position:absolute; top:260px; right:10px; display:flex; gap:6px; }
#regionControls button { padding:6px 8px; }

  .regionTile.hasPoints {
  outline: 2px solid rgba(255, 230, 0, 0.8);
  box-shadow: 0 0 6px rgba(255, 230, 0, 0.5);
}

#groupNameLabel {
  position: absolute;
  top: 290px;
  right: 70px; /* po lewej od przycisków */
  color: #fff;
  font-size: 14px;
  opacity: 0.8;
  font-weight: 500;
}
  
/* === LISTA UKŁADÓW (SIDEBAR) === */
#solarList {
  position: absolute;
  top: 300px;          /* poniżej regionControls (260px + trochę marginesu) */
  right: 10px;
  width: 240px;        /* taka sama szerokość jak regionMap */
  max-height: calc(100vh - 320px); /* nie wychodzi poza ekran */
  overflow-y: auto;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 6px;
  padding: 6px;
  box-sizing: border-box;
  color: white;
  font-size: 13px;
  backdrop-filter: blur(4px);
}

.solarItem {
  padding: 4px 6px;
  margin-bottom: 4px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(0,0,0,0.3);
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.2s;
}
.solarItem:hover {
  background: rgba(0,0,0,0.5);
}
.solarItem.selected {
  border-color: rgba(0,200,0,0.9);
  background: rgba(0,100,0,0.4);
}

  
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="hud">
  <div>X: <input type="number" id="xInput" value="0">
      Y: <input type="number" id="yInput" value="0">
      Z: <input type="number" id="zInput" value="0">
  </div>
  <div>Galactic: <input type="text" id="coordInput" placeholder="AAAA:BBBB:CCCC:DDDD"></div>
  <div>
    <button id="addPointSolarSystem">Dodaj punkt w regionie</button>
    <button id="zoomToPointSolarSystem">Zoom</button>
    <button id="editPointSolarSystem">Edytuj</button>
    <button id="deletePointSolarSystem">Usuń</button>
  </div>
</div>

<div id="regionMap"></div>
<div id="regionControls">
  <button id="enterGroup">+</button>
  <button id="exitGroup">-</button>
</div>
<div id="groupNameLabel"></div>
  
  <!-- Sidebar lista układów -->
<div id="solarList"></div>

<script>
/* ===============================
   Twój oryginalny kod — nie ruszałem niczego istotnego
   tylko dopisałem obsługę siatki regionów (2 poziomy).
   =============================== */

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);

// === Kamera i światło ===
const camera = new BABYLON.ArcRotateCamera("camera", Math.PI/4, Math.PI/4, 200, new BABYLON.Vector3(0,0,0), scene);
camera.attachControl(canvas,true);
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

// === Skybox ===
const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:10000}, scene);
const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);
skyboxMaterial.backFaceCulling=false;
skyboxMaterial.disableLighting=true;
skyboxMaterial.diffuseColor=new BABYLON.Color3(0,0,0);
skyboxMaterial.specularColor=new BABYLON.Color3(0,0,0);
skyboxMaterial.reflectionTexture=new BABYLON.CubeTexture("https://raw.githubusercontent.com/eLeRCreative84/NMS-Planet-Atlasv2/main/textures/skybox/sky1", scene);
skyboxMaterial.reflectionTexture.coordinatesMode=BABYLON.Texture.SKYBOX_MODE;
skybox.material = skyboxMaterial;

// === Regiony (fizyczne w świecie) ===
const REGION_WIDTH = 4096;
const REGION_DEPTH = 4096;
const REGION_HEIGHT = 256;

/* Uwaga: tu traktujemy model uproszczony:
   - globalnie mamy 16 x 16 regionów ułożonych w siatkę (index 0..15 po X i Z)
   - te 16x16 regionów są pogrupowane w 16 grup 4x4 (czyli GRID_GROUPS=4 po każdej osi)
*/
const GROUPS_PER_AXIS = 4;        // 4x4 grup = 16 grup (poziom GALAKTYKA)
const REGIONS_PER_GROUP = 4;      // 4x4 regionów w grupie = 16 regionów (poziom GRUPA)
const REGIONS_AXIS = GROUPS_PER_AXIS * REGIONS_PER_GROUP; // 16 regions per axis

let points = [];
let selectedPoint = null;
let regions = {}; // { "ix_iz": { node, points } }

// Tworzymy puste regiony z dummy anchorami, żeby kamera zawsze miała cel
for (let iz = 0; iz < REGIONS_AXIS; iz++) {
  for (let ix = 0; ix < REGIONS_AXIS; ix++) {
    const key = regionIndexKey(ix, iz);
    const node = new BABYLON.TransformNode(`region_${key}`, scene);

    // dummy mesh (niewidoczny, ale istnieje)
    const dummy = BABYLON.MeshBuilder.CreateBox(`dummy_${key}`, { size: 1 }, scene);
    dummy.isVisible = false;
    dummy.parent = node;
    dummy.position.set(ix * REGION_WIDTH + REGION_WIDTH/2, REGION_HEIGHT/2, iz * REGION_DEPTH + REGION_DEPTH/2);

    regions[key] = { node: node, points: [], dummy: dummy };
  }
}
  
// Materiały punktów
const pointMat = new BABYLON.StandardMaterial("pointMat", scene);
pointMat.emissiveColor = new BABYLON.Color3(0,1,0);
const selectedMat = new BABYLON.StandardMaterial("selectedMat", scene);
selectedMat.emissiveColor = new BABYLON.Color3(1,0,0);

// ==== pomocnik: klucz regionu bazowany na indeksie regionu (0..15)
function regionIndexKey(ix, iz){ return `${ix}_${iz}`; }

// ==== funkcja określająca indeks regionu z globalnych współrzędnych x,z
function regionKeyFromPosition(x,z){
  const ix = Math.floor(x / REGION_WIDTH);
  const iz = Math.floor(z / REGION_DEPTH);
  const clampedX = Math.max(0, Math.min(REGIONS_AXIS-1, ix));
  const clampedZ = Math.max(0, Math.min(REGIONS_AXIS-1, iz));
  return regionIndexKey(clampedX, clampedZ);
}

// === Kamera na punkt ===
function focusCameraOn(point,distance=50){
  const target = point.position.clone();
  const dir = camera.position.subtract(camera.target).normalize().scale(distance);
  const newPos = target.add(dir);
  BABYLON.Animation.CreateAndStartAnimation("camMove",camera,"position",60,60,camera.position.clone(),newPos,BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
  BABYLON.Animation.CreateAndStartAnimation("camTarget",camera,"target",60,60,camera.target.clone(),target,BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
}

/* === addSolarSystemPoint: zostawiamy jak było, ALE nie tworzymy tu kafelka w mapie
   (mapa jest niezależna i ma zawsze aktywne pola). */
function addSolarSystemPoint(x,y,z,gal){
  const ix = Math.floor(x / REGION_WIDTH);
  const iz = Math.floor(z / REGION_DEPTH);
  const key = regionIndexKey(ix,iz);

  if(!regions[key]){
    const node = new BABYLON.TransformNode(key,scene);
    regions[key] = { node: node, points: [] };
  }
  const region = regions[key];

  y = Math.min(Math.max(y,0), REGION_HEIGHT);

  const sphere = BABYLON.MeshBuilder.CreateSphere(`p${points.length}`,{diameter:2},scene);
  sphere.position.set(x,y,z);
  sphere.material = pointMat.clone();
  sphere.metadata = {galactic: gal};
  sphere.parent = region.node;
  region.points.push(sphere);
  points.push(sphere);

  sphere.actionManager = new BABYLON.ActionManager(scene);
  sphere.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger,()=>{
    if(selectedPoint) selectedPoint.material = pointMat.clone();
    selectedPoint = sphere; selectedPoint.material = selectedMat;
    document.getElementById("xInput").value = sphere.position.x.toFixed(2);
    document.getElementById("yInput").value = sphere.position.y.toFixed(2);
    document.getElementById("zInput").value = sphere.position.z.toFixed(2);
    document.getElementById("coordInput").value = gal || "";
  }));

  if(selectedPoint) selectedPoint.material = pointMat.clone();
  selectedPoint = sphere; selectedPoint.material = selectedMat;
  focusCameraOn(selectedPoint);

// === oznacz region na mapie jako aktywny (ma punkty)
if (level === 1) {
  const tile = document.querySelector(`.regionTile[data-ix='${ix}'][data-iz='${iz}']`);
  if (tile) tile.classList.add("hasPoints");
}
 
  addToSolarList(sphere);
}

/* ==============================
   --- TUTAJ DOPISUJEMY SIATKĘ ---
   ============================== */

const regionMapEl = document.getElementById("regionMap");
const enterBtn = document.getElementById("enterGroup");
const exitBtn = document.getElementById("exitGroup");
const groupNameLabel = document.getElementById("groupNameLabel");


let level = 0; 
let selectedTile = null;
let currentGroupX = 0;
let currentGroupZ = 0;

// helper: wyczysc selection
function clearSelectionTile(){
  if(selectedTile) { selectedTile.classList.remove("selected"); selectedTile = null; }
}

// rysowanie widoku GALAKTYKI (4x4 grup)
function drawGalaxyGrid(){
  regionMapEl.innerHTML = "";
  clearSelectionTile();
  for(let gz=0; gz<4; gz++){
    for(let gx=0; gx<4; gx++){
      const tile = document.createElement("div");
      tile.className = "regionTile";
      tile.dataset.gx = gx;
      tile.dataset.gz = gz;
      tile.addEventListener("click", ()=> {
        if(selectedTile) selectedTile.classList.remove("selected");
        selectedTile = tile;
        tile.classList.add("selected");
      });
      regionMapEl.appendChild(tile);
    }
  }
}

// rysowanie widoku GRUPY (4x4 regionów)
function drawGroupGrid(groupX, groupZ){
  regionMapEl.innerHTML = "";
  clearSelectionTile();
  for(let rz=0; rz<4; rz++){
    for(let rx=0; rx<4; rx++){
      const tile = document.createElement("div");
      tile.className = "regionTile";
      const regionX = groupX * REGIONS_PER_GROUP + rx;
      const regionZ = groupZ * REGIONS_PER_GROUP + rz;
      tile.dataset.ix = regionX;
      tile.dataset.iz = regionZ;
      tile.addEventListener("click", ()=>{
        if(selectedTile) selectedTile.classList.remove("selected");
        selectedTile = tile;
        tile.classList.add("selected");
        
        const key = regionIndexKey(regionX, regionZ);
        const region = regions[key];
        if (region && region.dummy) {
          camera.setTarget(region.dummy.position.clone());
        } else {
          const fallback = new BABYLON.Vector3(
            regionX * REGION_WIDTH + REGION_WIDTH/2,
            REGION_HEIGHT/2,
            regionZ * REGION_DEPTH + REGION_DEPTH/2
          );
          camera.setTarget(fallback);
}
camera.alpha = Math.PI / 4;
camera.beta = Math.PI / 4;
camera.radius = 1200;
camera.minZ = 0.1;
camera.maxZ = 20000;

      });
      regionMapEl.appendChild(tile);
    }
  }
}

enterBtn.addEventListener("click", ()=>{
  if(level !== 0) return;
  if(!selectedTile) return alert("Zaznacz grupę, w którą chcesz wejść.");
  const gx = parseInt(selectedTile.dataset.gx);
  const gz = parseInt(selectedTile.dataset.gz);
  currentGroupX = gx; currentGroupZ = gz;
  level = 1;
  const groupIndex = gz * GROUPS_PER_AXIS + gx + 1;
  groupNameLabel.textContent = `Grupa regionów ${groupIndex}`;
  drawGroupGrid(currentGroupX, currentGroupZ);
});

exitBtn.addEventListener("click", ()=>{
  if(level !== 1) return;
  level = 0;
  currentGroupX = 0; currentGroupZ = 0;
  drawGalaxyGrid();
});

drawGalaxyGrid();
groupNameLabel.textContent = "";

/* ===============================
   SIDEBAR – lista układów
   =============================== */
const solarListEl = document.getElementById("solarList");

// funkcja tworząca nowy wpis w liście
function addToSolarList(sphere) {
  const item = document.createElement("div");
  item.className = "solarItem";
  item.textContent = sphere.metadata.galactic || `Układ #${points.length}`;
  item.dataset.id = sphere.name;

  item.addEventListener("click", () => {
    // usuwamy zaznaczenie poprzedniego
    document.querySelectorAll(".solarItem").forEach(el => el.classList.remove("selected"));
    item.classList.add("selected");

    // podświetlenie w 3D
    if (selectedPoint) selectedPoint.material = pointMat.clone();
    selectedPoint = sphere;
    selectedPoint.material = selectedMat;

    // wypełnij inputy
    xInput.value = sphere.position.x.toFixed(2);
    yInput.value = sphere.position.y.toFixed(2);
    zInput.value = sphere.position.z.toFixed(2);
    coordInput.value = sphere.metadata.galactic || "";

    focusCameraOn(sphere);
  });

  solarListEl.appendChild(item);
}

// aktualizacja listy po usunięciu punktu
function removeFromSolarList(sphere) {
  const el = solarListEl.querySelector(`[data-id="${sphere.name}"]`);
  if (el) el.remove();
}

/* ================================
   Reszta Twojego HUD (bez zmian)
   ================================ */

const xInput=document.getElementById("xInput");
const yInput=document.getElementById("yInput");
const zInput=document.getElementById("zInput");
const coordInput=document.getElementById("coordInput");

document.getElementById("addPointSolarSystem").addEventListener("click",()=>{
  const gal = coordInput.value.trim();
  let x = parseFloat(xInput.value);
  let y = parseFloat(yInput.value);
  let z = parseFloat(zInput.value);

  // === PRZYPADEK 1: Koordynaty Galactic są wypełnione ===
  if (gal && gal.includes(":")) {
    // Przykładowy format: AAAA:BBBB:CCCC:DDDD
    // Można tu rozszerzyć na dokładniejsze mapowanie regionów.
    const parts = gal.split(":").map(p => parseInt(p,16) || 0);

    // uproszczone odwzorowanie galaktyczne -> współrzędne regionu
    const gx = parts[2] % REGIONS_AXIS;
    const gz = parts[3] % REGIONS_AXIS;

    x = gx * REGION_WIDTH + REGION_WIDTH / 2;
    z = gz * REGION_DEPTH + REGION_DEPTH / 2;
    y = Math.min(Math.max(y || 0, 0), REGION_HEIGHT);

    addSolarSystemPoint(x, y, z, gal);
    return;
  }

  // === PRZYPADEK 2: Użytkownik dodaje ręcznie (brak Galactic) ===
  // Musi być wybrany region (czyli jesteśmy na poziomie grupy)
  if (level !== 1 || !selectedTile || !selectedTile.dataset.ix) {
    alert("Wybierz region z mapy, zanim dodasz punkt ręcznie.");
    return;
  }

  // obliczamy pozycję względem wybranego regionu
  const ix = parseInt(selectedTile.dataset.ix);
  const iz = parseInt(selectedTile.dataset.iz);

  // jeśli użytkownik nie podał współrzędnych X/Z, tworzymy w środku regionu
  if (isNaN(x)) x = ix * REGION_WIDTH + REGION_WIDTH / 2;
  if (isNaN(z)) z = iz * REGION_DEPTH + REGION_DEPTH / 2;
  if (isNaN(y)) y = REGION_HEIGHT / 2;

  addSolarSystemPoint(x, y, z, gal);
});


document.getElementById("zoomToPointSolarSystem").addEventListener("click",()=>{ if(selectedPoint) focusCameraOn(selectedPoint); });
document.getElementById("editPointSolarSystem").addEventListener("click",()=>{
  if(!selectedPoint) return alert("Nie zaznaczono punktu!");
  selectedPoint.position.set(parseFloat(xInput.value),parseFloat(yInput.value),parseFloat(zInput.value));
  selectedPoint.metadata.galactic = coordInput.value.trim();
});
document.getElementById("deletePointSolarSystem").addEventListener("click",()=>{
  if(!selectedPoint) return alert("Nie zaznaczono punktu!");
  const ix = Math.floor(selectedPoint.position.x / REGION_WIDTH);
  const iz = Math.floor(selectedPoint.position.z / REGION_DEPTH);
  const key = regionIndexKey(ix,iz);
  const region = regions[key];
  if(region) region.points = region.points.filter(p=>p!==selectedPoint);
  points = points.filter(p=>p!==selectedPoint);
  selectedPoint.dispose();
  removeFromSolarList(selectedPoint);
  selectedPoint=null;
});

// === Render ===
engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>




