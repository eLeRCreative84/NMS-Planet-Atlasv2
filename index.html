<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8">
<title>Mapa 3D z skyboxem z GitHub</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
  #renderCanvas { width:100vw; height:100vh; touch-action:none; display:block; }
  #hud {
    position: absolute; top: 10px; left: 10px; padding:10px;
    background: rgba(0,0,0,0.6); color:white; border-radius:5px;
  }
  #hud input { width:50px; margin-right:5px; }
  #hud button { margin-left:5px; }
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div id="hud">
  X: <input type="number" id="xInput" value="0">
  Y: <input type="number" id="yInput" value="0">
  Z: <input type="number" id="zInput" value="0">
  <button id="addPoint">Dodaj punkt</button>
  <button id="zoomToPoint">Zoom do wybranego punktu</button>
</div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// Kamera orbitująca
const camera = new BABYLON.ArcRotateCamera("camera", Math.PI/4, Math.PI/4, 100, new BABYLON.Vector3(0,0,0), scene);
camera.attachControl(canvas, true);

// Światło
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

// Skybox
const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:10000}, scene);
const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);
skyboxMaterial.backFaceCulling = false;
skyboxMaterial.disableLighting = true;
skyboxMaterial.diffuseColor = new BABYLON.Color3(0,0,0);
skyboxMaterial.specularColor = new BABYLON.Color3(0,0,0);

skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
  "https://raw.githubusercontent.com/eLeRCreative84/NMS-Planet-Atlasv2/main/textures/skybox/sky1",
  scene
);
skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
skybox.material = skyboxMaterial;

// === PUNKTY I WĘZŁY ===
let points = [];
let selectedPoint = null;

const pointMaterial = new BABYLON.StandardMaterial("pointMat", scene);
pointMaterial.emissiveColor = new BABYLON.Color3(0, 1, 0); // jaskrawozielony

const selectedMaterial = new BABYLON.StandardMaterial("selectedMat", scene);
selectedMaterial.emissiveColor = new BABYLON.Color3(1, 0, 0); // czerwony

const lineMaterial = new BABYLON.StandardMaterial("lineMat", scene);
lineMaterial.emissiveColor = new BABYLON.Color3(1, 1, 0); // żółty

function addPoint(x, y, z) {
  const sphere = BABYLON.MeshBuilder.CreateSphere(`p${points.length}`, { diameter: 2 }, scene);
  sphere.position.set(x, y, z);
  sphere.material = pointMaterial.clone();

  // Kliknięcie w punkt
  sphere.actionManager = new BABYLON.ActionManager(scene);
  sphere.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
    BABYLON.ActionManager.OnPickTrigger,
    function (evt) {
      if (selectedPoint) selectedPoint.material = pointMaterial.clone();
      selectedPoint = sphere;
      selectedPoint.material = selectedMaterial;
    }
  ));

  // Dodaj połączenie z poprzednim punktem (jeśli istnieje i był zaznaczony)
  if (selectedPoint && selectedPoint !== sphere) {
    const path = [selectedPoint.position, sphere.position];
    const line = BABYLON.MeshBuilder.CreateLines("line", { points: path, updatable: false }, scene);
    line.color = new BABYLON.Color3(1, 1, 0); // żółty
    line.material = lineMaterial;
  }

  points.push(sphere);

  // Nowy punkt staje się wybranym
  if (selectedPoint) selectedPoint.material = pointMaterial.clone();
  selectedPoint = sphere;
  selectedPoint.material = selectedMaterial;

  // Kamera – automatyczny zoom do nowego punktu
  const target = sphere.position.clone();
  const distance = 10;
  const direction = camera.position.subtract(camera.target).normalize().scale(distance);
  const newPosition = target.add(direction);

  BABYLON.Animation.CreateAndStartAnimation("camMove", camera, "position", 60, 60,
    camera.position.clone(), newPosition, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
  BABYLON.Animation.CreateAndStartAnimation("camTarget", camera, "target", 60, 60,
    camera.target.clone(), target, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
}

// === HUD ===
document.getElementById('addPoint').addEventListener('click', () => {
  const x = parseFloat(document.getElementById('xInput').value);
  const y = parseFloat(document.getElementById('yInput').value);
  const z = parseFloat(document.getElementById('zInput').value);
  addPoint(x, y, z);
});

document.getElementById('zoomToPoint').addEventListener('click', () => {
  if (!selectedPoint) return;
  const target = selectedPoint.position.clone();
  const distance = 10;
  const direction = camera.position.subtract(camera.target).normalize().scale(distance);
  const newPosition = target.add(direction);

  BABYLON.Animation.CreateAndStartAnimation("camMove", camera, "position", 60, 60,
    camera.position.clone(), newPosition, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
  BABYLON.Animation.CreateAndStartAnimation("camTarget", camera, "target", 60, 60,
    camera.target.clone(), target, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
});

// Render loop
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>


</body>
</html>








